{"version":3,"sources":["middleware.ts","makeReducer.ts","demo/User.ts","demo/LoadInfo.ts","demo/UserInfoPane.tsx","makeReducer-bak.ts","immer/makeReducer.ts","immer/Demo1.ts","immer/Demo1UI.tsx","immer/use1.tsx","immer/makeAction.tsx","demo/App.tsx","store.ts","mobx/Demo1.tsx","immer/models/Model.ts","immer/Tools.ts","immer/models/Student.ts","index.tsx"],"names":["asyncMiddleware","dispatch","getState","next","action","buildActionType","modelName","type","parseActiontype","reduxType","separatorIndex","indexOf","substring","User","modelConfig","reducers","name","initialState","state","infer","handler","inferEffect","baseReducer","payload","parsedArr","reducer","find","r","err","Error","console","error","subscribe","rs","effects","actions","push","createModel","loadStatus","loadMsg","id","label","setName","loadDone","loadError","loading","beforeload","addLabel","test","delay","Promise","resolve","reject","setTimeout","then","data","catch","connect","user","users","tests","props","placeholder","disabled","onClick","e","inputNode","document","querySelector","value","log","JSON","stringify","makeReducer","namespace","s","n","realType","result","Test","update","Demo1","desc","setID","delaySetName","Demo1UI","useReducer","x","use1","config","model","reducerDispatch","k","actionData","makeAction","useState","title","state3","setState3","Math","random","dangerouslySetInnerHTML","__html","reducers2","rootReducer","combineReducers","store","applyMiddleware","createReduxStore","todoStore","observable","todos","this","filter","todo","completed","length","autorun","completedCount","Model","undefined","inferReducer","Student","target","propertyKey","descriptor","enumerable","wrapper","createElement","body","append","ReactDOM","render"],"mappings":"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","file":"static/js/main.6aa8e8ef.chunk.js","sourcesContent":["export type AsyncDispatch = <PR>(action: (...args: any[]) => any) => Promise<PR>;\n\nfunction createMiddleware() {\n    return ({ dispatch, getState }) => next => action => {\n        if (typeof action === \"function\") {\n            return action(dispatch, getState);\n        }\n\n        return next(action);\n    };\n}\n\nlet asyncMiddleware = createMiddleware();\n\nexport default asyncMiddleware;","import { Dispatch } from \"redux\";\n\nconst separator = ':';\n\ntype FuncName<T>  = {\n    [k in keyof T]: T[k] extends Function ? k : never;\n}[keyof T];\n\ntype Reducer<S, P, T = string> = (state: S, payload: P, type: T) => Partial<S>; // TODO 是否可返回部分State？\n// type Reducer<S, P, T = string> = (state: S, payload: P, type: T) => S;\ntype Effect<S, P, PromiseResult> = (payload: P, dispatch: ReduxDispatch, getState: () => S) => Promise<PromiseResult>;\ntype InvalidMethod = never;\n\nexport type ReduxDispatch = Dispatch;\n\nconst buildActionType = (modelName: string, type: string) => {\n    return modelName + separator + type;\n}\nconst parseActiontype = (reduxType: string) => {\n    let separatorIndex = reduxType.indexOf(':'),\n        modelName = reduxType.substring(0, separatorIndex),\n        actionType = reduxType.substring(separatorIndex + 1);\n        \n    return [modelName, actionType];\n}\n\ntype ModelConfig<S> = {\n    name: string;\n    state: S;\n}\nexport const createModel = <S>(modelConfig: ModelConfig<S>) => {\n    const reducers: [string, Reducer<S, unknown, string>][] = [];\n\n    let { name: modelName, state: initialState } = modelConfig;\n    \n    const baseReducer = (state = initialState, action: { type: string; payload }) => {\n        let { type: reduxType, payload } = action,\n            parsedArr = parseActiontype(reduxType),\n            type = parsedArr[1];\n\n        if (parsedArr[0] !== modelName)\n            return state;\n            \n        let reducer = reducers.find(r => r[0] === type);\n\n        if (reducer)\n            return { ...state, ...reducer[1](state, payload, type) };\n        else {\n            let err = new Error(`action.type = ${reduxType}没有对应的reducer处理函数`);\n            console.error(err);\n            return state;\n        }\n    }\n\n    // type Infer = <P, PR, Func = Reducer<S, P> | Effect<S, P, PR>>(handler: Func) => Func extends Effect<S, infer P, infer PR> ? Effect<S, P, PR> :\n    //             Func extends Reducer<S, infer P, infer T> ? Reducer<S, P, T> : InvalidMethod;\n    // const infer: Infer = (handler) => {\n    //     return handler as any;\n    // }\n\n    // type InferEffect = <P, PR>(handler: Effect<S, P, PR>) => Effect<S, P, PR>;\n    // type InferReducer = <P>(handler: Reducer<S, P>) => Reducer<S, P>;\n    // type Infer = InferReducer | InferEffect;\n    const infer = <P>(handler: Reducer<S, P>) => {\n        return handler;\n    }\n    const inferEffect = <P, PR>(handler: Effect<S, P, PR>) => {\n        return handler;\n    }\n\n    type InferFunc<Func> = Func extends Effect<S, infer P, infer PR> ? (payload: P) => (...args: any[]) => Promise<PR> :\n                            Func extends Reducer<S, infer P, infer T> ? (payload: P) => { payload: P, type: T } : InvalidMethod;\n\n    type Subscribe = <Reducers, Effects, Mix = Reducers & Effects>(reducers?: Reducers, effects?: Effects) => {\n        [k in FuncName<Mix>]: InferFunc<Mix[k]>\n    }\n\n    const subscribe: Subscribe = (rs, effects) => {\n        let actions: any = {};\n\n        for (let type in rs) {\n            actions[type] = (payload) => {\n                return { type: buildActionType(modelName, type), payload };\n            }\n            reducers.push([type, rs[type] as any]);\n        }\n\n        for (let type in effects) {\n            let handler = effects[type];\n            actions[type] = (payload) => {\n                return (...args) => {\n                    return typeof handler === 'function' && handler(payload, args[0], args[1]);\n                }\n            };\n        }\n\n        return actions;\n    }\n\n    // const setState = (payload: Partial<S>) => {\n    //     return { payload, type: buildActionType(modelName, 'setState') };\n    // }\n    // reducers.push(['setState', (state: S, action: { payload: Partial<S>, type: 'setState' }) => {\n    //     return {...state, ...action.payload};\n    // }]);\n    \n    return {\n        infer,\n        inferEffect,\n        // setState,\n        baseReducer,\n        subscribe,\n    };\n}\n\nexport const assignActions = <T, A>(target: T, actions: A) => {\n    return Object.assign(target, { actions });\n}","import { createModel } from \"../makeReducer\";\nimport { mergeLoadReducers, LoadInfo } from \"./LoadInfo\";\n\nexport type UserModel = {\n    id: string;\n    name: string;\n    label: string[];\n} & LoadInfo;\n\nconst User = createModel<UserModel>(\n    {\n        name: 'User',\n        state: {\n            loadStatus: 'beforeload',\n            loadMsg: '',\n            name: 'tom',\n            id: '5858fccee138233f9d645621',\n            label: ['student', 'human'],\n        }\n    }\n);\n\n// let x = (a: number) => {return new Error()};\n// let y = (b: number, s: string) => {return new TypeError()};\n\n// x = y;\n// let z = y = x;\n\n// type t = typeof x extends typeof y ? true : false;\n\n\n// let x2 = () => ({name: \"Alice\"});\n// let y2 = () => ({name: \"Alice\", location: \"Seattle\"});\n// type t2 = typeof x2 extends typeof y2 ? true : false;\n\n// interface Empty<T> {\n//     data?: T;\n// }\n// let x3: Empty<number> = {};\n// let y3: Empty<string> = {};\n\n// x3 = y3;\nlet { subscribe, infer, inferEffect } = User;\n\nlet infer1 = infer((state, payload: UserModel['loadStatus'], type) => {\n    return {...state, loadStatus: payload};\n});\nlet actions = subscribe(\n    {\n        setName: (state, payload: string, type) => {\n            return {...state, name: payload};\n        },\n        loadStatus: infer((state, payload: UserModel['loadStatus'], type) => {\n                return {...state, loadStatus: payload};\n        }),\n        ...mergeLoadReducers(),\n        addLabel: infer((state, payload: UserModel['label'], type) => {\n            return {...state , label: [...state.label, ...payload]};\n        }),\n        test: infer((state, payload, type) => { // 错误的订阅，将无法生成可调用的action方法\n            return {...state};\n        })\n    }, \n    {\n        // setName: () => {return Promise.resolve('123')},\n        delay: inferEffect((payload: string, dispatch, getState) => {\n            dispatch(actions.loading('loading'));\n            return new Promise<string>((resolve, reject) => {\n                setTimeout(() => {\n                    resolve(payload);\n                }, 500);\n            }).then((data) => {\n                dispatch(actions.loadDone('done'));\n                dispatch(actions.addLabel([payload]));\n                return data;\n            }).catch(()=> {\n                dispatch(actions.loadError('error'));\n            })\n        })\n    }\n);\n// actions.setName(123);\n// actions.addLabel([123123]);\n// actions.test('222');\n\nexport default User;\nexport { actions };","export type LoadInfo = {\n    loadStatus: 'beforeload' | 'loading' | 'done' | 'error';\n    loadMsg: '';\n}\n\nconst mergeLoadReducers = <S extends LoadInfo>() => {\n\n    type LoadReducer = (state: S, payload: LoadInfo, type) => S;\n    const loadStatus: LoadReducer = (state, payload, type) => {\n        return { ...state, loadStatus: payload };\n    }\n\n    type LoadReducer2 = (state: S, payload: string | undefined, type: string) => S;\n    const loadDone: LoadReducer2 = (state, payload) => {\n        return { ...state, loadMsg: payload };\n    }\n    const loadError: LoadReducer2 = (state, payload) => {\n        return { ...state, loadMsg: payload };\n    }\n    const loading: LoadReducer2 = (state, payload) => {\n        return { ...state, loadMsg: payload };\n    }\n    const beforeload: LoadReducer2 = (state, payload) => {\n        return { ...state, loadMsg: payload };\n    }\n\n    return {\n        loadStatus,\n        loadDone,\n        loadError,\n        loading,\n        beforeload,\n    }\n}\n\nexport {\n    mergeLoadReducers,\n}","import { connect } from \"react-redux\";\nimport React from \"react\";\nimport { RootState } from \"./App\";\nimport User, { actions, UserModel } from \"./User\";\nimport { Dispatch } from \"redux\";\nimport { ReduxDispatch } from \"../makeReducer\";\nimport { AsyncDispatch } from \"../middleware\";\n\ntype Props = {\n    user: UserModel;\n    loadStatus: string;\n    name: string;\n    label: string[];\n    dispatch: ReduxDispatch & AsyncDispatch;\n};\n\nexport default connect(\n    (state: RootState) => ({\n        user: state.users.user,\n        name: state.tests.test.name,\n        label: state.users.user.label,\n        loadStatus: state.users.user.loadStatus,\n        // label: state.test2.label,\n    })\n)((props: Props) => {\n        return <div> \n            <input placeholder=\"请填写label\" id=\"label-input\"/>\n            <button disabled={props.loadStatus === 'loading'} onClick={e => {\n                let inputNode = document.querySelector<HTMLInputElement>('#label-input');\n\n                props.dispatch(actions.addLabel([inputNode ? inputNode.value : '']));\n            }}>立即添加一个label!</button>\n            <button disabled={props.loadStatus === 'loading'} onClick={e => {\n                let inputNode = document.querySelector<HTMLInputElement>('#label-input');\n                let result = props.dispatch(actions.delay(inputNode ? inputNode.value : ''));\n\n                result.then(function(data) {\n                    console.log('promise then:', data);\n                })\n            }}>延迟一段时间后，添加label!</button>\n            <p>用户信息: </p>\n            <pre>\n                {JSON.stringify(props.user, null, 4)}\n            </pre>\n        </div>;\n    }\n)","type Reducer<S> = (\n    state: S, \n    action: {\n        type: string,\n    } & Partial<S>\n) => Partial<S> | undefined;\n\nconst makeReducer = <N extends string, S, Action extends string | symbol | number>({\n    namespace,\n    initialState,\n    reducers,\n}: {\n    namespace: N;\n    initialState: S, \n    reducers: {\n        [k in Action]: \n        Reducer<S>\n    },\n}) => {\n    let actions: {[k in Action]?: (s: Partial<S>) => {type: string} & Partial<S>} = {};\n\n    for (let name in reducers) {\n        actions[name] = (s: Partial<S>) => {\n            return { ...s, type: namespace + ':' + name };\n        }\n    }\n\n    return {\n        actions: actions as Required<typeof actions>,\n        reducer: (state: S = initialState, action: {\n            type: string;\n        } & Partial<S>) => {\n            let { type } = action,\n                separatorIndex = type.indexOf(':'),\n                n = type.substring(0, separatorIndex),\n                realType = type.substring(separatorIndex + 1),\n                reducer: Reducer<S> | undefined; \n\n            if (n !== namespace)\n                return state;\n\n            for (let name in reducers) {\n                if (name === realType) {\n                    reducer = reducers[name];\n                }\n            }\n    \n            // TODO action未匹配到reducer函数，是否该throw Error?\n            if (!reducer) {\n                let err = new Error(`action:${action}没有对应的reducer处理函数`);\n                console.error(err);\n                return state;\n            }\n\n            let result = reducer(state, action);\n\n            console.log(result, reducer);\n            if (!result)\n                return state;\n            else \n                return { ...state, ...result };\n        }\n    }\n}\n\nexport default makeReducer;\n\nconst Test = makeReducer({\n    namespace: 'test',\n    initialState: {\n        name: 'tom',\n        id: '5858fccee138233f9d645621',\n        label: ['student', 'human'],\n    },\n    reducers: {\n        update(state, action) {\n            let { type, ...rest } = action;\n\n            return { ...rest };\n        },\n        addLabel(state, action) {\n            let { label } = action;\n\n            if (!label) {\n                return;\n            }\n            return { label: [...state.label, ...label] };\n        }\n    }\n});\n\nexport { Test };","const separator = ':';\n\ntype FuncName<T>  = {\n    [k in keyof T]: T[k] extends Function ? k : never;\n}[keyof T];\n\ntype Reducer<S, P, T = string> = (state: S, payload: P, type: T) => Partial<S>; // TODO 是否可返回部分State？\n// type Reducer<S, P, T = string> = (state: S, payload: P, type: T) => S;\ntype Effect<S, P, PromiseResult> = (payload: P, dispatch: Dispatch, getState: () => S) => Promise<PromiseResult>;\ntype InvalidMethod = never;\n\nexport type Dispatch = React.Dispatch<{payload: any; type: string}>;\n\nconst buildActionType = (modelName: string, type: string) => {\n    return modelName + separator + type;\n}\nconst parseActiontype = (reduxType: string) => {\n    let separatorIndex = reduxType.indexOf(':'),\n        modelName = reduxType.substring(0, separatorIndex),\n        actionType = reduxType.substring(separatorIndex + 1);\n        \n    return [modelName, actionType];\n}\n\ntype ModelConfig<S> = {\n    name: string;\n    state: S;\n}\nexport const createModel = <S>(modelConfig: ModelConfig<S>) => {\n    const reducers: [string, Reducer<S, unknown, string>][] = [];\n\n    let { name: modelName, state: initialState } = modelConfig;\n    \n    const baseReducer = (state = initialState, action: { type: string; payload }) => {\n        let { type: reduxType, payload } = action,\n            parsedArr = parseActiontype(reduxType),\n            type = parsedArr[1];\n\n        if (parsedArr[0] !== modelName)\n            return state;\n            \n        let reducer = reducers.find(r => r[0] === type);\n\n        if (reducer)\n            return { ...state, ...reducer[1](state, payload, type) };\n        else {\n            let err = new Error(`action.type = ${reduxType}没有对应的reducer处理函数`);\n            console.error(err);\n            return state;\n        }\n    }\n\n    // type Infer = <P, PR, Func = Reducer<S, P> | Effect<S, P, PR>>(handler: Func) => Func extends Effect<S, infer P, infer PR> ? Effect<S, P, PR> :\n    //             Func extends Reducer<S, infer P, infer T> ? Reducer<S, P, T> : InvalidMethod;\n    // const infer: Infer = (handler) => {\n    //     return handler as any;\n    // }\n\n    // type InferEffect = <P, PR>(handler: Effect<S, P, PR>) => Effect<S, P, PR>;\n    // type InferReducer = <P>(handler: Reducer<S, P>) => Reducer<S, P>;\n    // type Infer = InferReducer | InferEffect;\n    const infer = <P>(handler: Reducer<S, P>) => {\n        return handler;\n    }\n    const inferEffect = <P, PR>(handler: Effect<S, P, PR>) => {\n        return handler;\n    }\n\n    type InferFunc<Func> = Func extends Effect<S, infer P, infer PR> ? (payload: P) => (...args: any[]) => Promise<PR> :\n                            Func extends Reducer<S, infer P, infer T> ? (payload: P) => { payload: P, type: T } : InvalidMethod;\n\n    type Subscribe = <Reducers, Effects, Mix = Reducers & Effects>(reducers?: Reducers, effects?: Effects) => {\n        [k in FuncName<Mix>]: InferFunc<Mix[k]>\n    }\n\n    const subscribe: Subscribe = (rs, effects) => {\n        let actions: any = {};\n\n        for (let type in rs) {\n            actions[type] = (payload) => {\n                return { type: buildActionType(modelName, type), payload };\n            }\n            reducers.push([type, rs[type] as any]);\n        }\n\n        for (let type in effects) {\n            let handler = effects[type];\n            actions[type] = (payload) => {\n                return (...args) => {\n                    return typeof handler === 'function' && handler(payload, args[0], args[1]);\n                }\n            };\n        }\n\n        return actions;\n    }\n\n    // const setState = (payload: Partial<S>) => {\n    //     return { payload, type: buildActionType(modelName, 'setState') };\n    // }\n    // reducers.push(['setState', (state: S, action: { payload: Partial<S>, type: 'setState' }) => {\n    //     return {...state, ...action.payload};\n    // }]);\n    \n    return {\n        infer,\n        inferEffect,\n        // setState,\n        baseReducer,\n        subscribe,\n    };\n}\n\nexport const assignActions = <T, A>(target: T, actions: A) => {\n    return Object.assign(target, { actions });\n}","import { createModel } from \"./makeReducer\";\n\ntype Demo1 = {\n    name: string;\n    id: string;\n    desc: string;\n}\nexport const Demo1 = createModel<Demo1>({\n    name: 'demo1',\n    state: {\n        name: 'x',\n        id: 'y',\n        desc: 'x an y'\n    }\n});\n\nexport const actions = Demo1.subscribe(\n    {\n        setName: Demo1.infer((state, payload: string, type) => {\n            return {\n                ...state,\n                name: payload,\n            };\n        }),\n        setID: Demo1.infer((state, payload: string, type) => {\n            return {\n                ...state,\n                id: payload\n            };\n        })\n    },\n    {\n        delaySetName: Demo1.inferEffect((payload: string, dispatch, getState) => {\n            console.log('setTimeout before', getState());\n            return new Promise((resolve, reject) => {\n                setTimeout(() => {\n                    console.log('setTimeout', getState());\n                    dispatch(actions.setName(payload));\n                    console.log('setName after', getState());\n                    resolve(getState());\n                }, 3000);\n            })\n        })\n    });","/* eslint-disable react-hooks/rules-of-hooks */\nimport { makeAction } from \"./makeAction\";\nimport { actions, Demo1 } from \"./Demo1\";\nimport React, { useReducer, useState } from \"react\";\nimport use1 from \"./use1\";\n\nexport default function Demo1UI() {\n    let { state: state1, dispatch: dispatch1 } = use1();\n    let [state, dispatch] = makeAction({\n        initialState: {\n            name: 'x',\n            id: 'y'\n        },\n        actions: actions,\n        model: Demo1,\n    });\n    let [state3, setState3] = useState({\n        id: 'state3',\n        title: '状态3',\n        loadStatus: 'beforeload',\n    });\n\n    // dispatch.setName('xxx');\n    // dispatch.delaySetName('222');\n    \n    return <div>\n            <div onClick={e => {\n                dispatch.delaySetName(Math.random() + '');\n            }}>{state.name}</div>\n            <div dangerouslySetInnerHTML={{__html: '<百度>xxxx</百度>'}}></div>\n            <div onClick={e => {\n                dispatch.setID(state.id + 1);\n                dispatch.delaySetName(state.name + '1');\n            }}>click herer! Demo1.state = {JSON.stringify(state)}</div>\n            <div onClick={e => {\n                setState3({\n                    ...state3,\n                    loadStatus: 'loading',\n                });\n                setTimeout(() => {\n                    console.log(state3);\n                    setState3({\n                        ...state3,\n                        loadStatus: 'loaded'\n                    });\n                    console.log(state3);\n                }, 3000);\n                setTimeout(() => {\n                    setState3({\n                        ...state3,\n                        id: state3.id + '1',\n                    });\n                }, 1000);\n            }}>click here! stat3 = {JSON.stringify(state3)}</div>\n    </div>;\n}","import { useReducer } from \"react\";\n\nexport default function use1() {\n    let [ state, dispatch ] = useReducer((state) => {\n        // console.log(state.x);\n        return { x: state.x + 1 };\n    }, {x: 1});\n\n    return {state, dispatch};\n}","/* eslint-disable react-hooks/rules-of-hooks */\nimport { useReducer } from \"react\";\nimport { AnyObject } from \"immer/dist/internal\";\n\nexport function makeAction<State, Actions extends AnyObject, Model>(config: {\n    actions: Actions;\n    model: Model;\n    initialState: State\n}) {\n    let [state, reducerDispatch] = useReducer(config.model['baseReducer'], config.initialState);\n    let { actions, initialState, model } = config;\n    // console.log('model', model);\n\n    let dispatch = {} as any;\n\n    function getState() {\n        return state;\n    }\n    for (let k in actions) {\n        dispatch[k] = (payload) => {\n            let actionData = actions[k](payload);\n\n            if (typeof actionData === 'function') {\n                return actionData(reducerDispatch, getState);\n            } else \n                return reducerDispatch(actionData);\n        }\n    }\n    \n    return [\n        state as State,\n        dispatch as {\n            [k in keyof Actions]: (...args: Parameters<Actions[k]>) => ReturnType<Actions[k]> extends Function ? ReturnType<Actions[k]> : void;\n        },\n    ] as const\n}","import { Provider, connect } from \"react-redux\";\nimport { makeStore } from '../store';\n\nimport React from \"react\";\nimport { combineReducers } from \"redux\";\nimport UpdateMsg from \"./UserInfoPane\";\n\nimport { applyMiddleware } from 'redux';\nimport User from \"./User\";\nimport asyncMiddleware from \"../middleware\";\nimport { Test } from \"../makeReducer-bak\";\nimport Demo1UI from \"../immer/Demo1UI\";\n\nfunction logger({ getState }) {\n    // debugger;\n  return next => action => {\n    //   debugger;\n    console.log('will dispatch', action)\n\n    // Call the next dispatch method in the middleware chain.\n    const returnValue = next(action)\n\n    console.log('state after dispatch', getState())\n\n    // This will likely be the action itself, unless\n    // a middleware further in chain changed it.\n    return returnValue\n  }\n}\n\n\nconst reducers = {\n    test: Test.reducer,\n};\n\nconst reducers2 = {\n    user: User.baseReducer,\n}\n\nlet rootReducer = combineReducers({\n    tests: combineReducers(reducers),\n    users: combineReducers(reducers2),\n});\n\nexport type RootState = ReturnType<typeof rootReducer>;\n\nconst store = makeStore(rootReducer, applyMiddleware(asyncMiddleware));\n\nconsole.log(store);\nexport default () => {\n    return  (\n        <Provider store={store}>\n            <UpdateMsg />\n            <Demo1UI />\n        </Provider>\n    )\n}","import { createStore as createReduxStore, applyMiddleware } from \"redux\";\n\nimport asyncMiddleware from \"./middleware\";\n\ntype CreateStore = typeof createReduxStore;\nconst makeStore: CreateStore = (reducer) => {\n    const store = createReduxStore(reducer, applyMiddleware(asyncMiddleware));\n    return store;\n}\n\nexport {\n    makeStore\n}\n","import {observable, autorun} from 'mobx';\n\nvar todoStore = observable({\n    /* 一些观察的状态 */\n    todos: [] as Array<{ title: string, completed: boolean }>,\n\n    /* 推导值 */\n    get completedCount() {\n        return this.todos.filter(todo => todo.completed).length;\n    }\n});\n\n/* 观察状态改变的函数 */\nautorun(function() {\n    console.log(\"Completed %d of %d items\",\n        todoStore.completedCount,\n        todoStore.todos.length\n    );\n});\n\n/* ..以及一些改变状态的动作 */\ntodoStore.todos[0] = {\n    title: \"Take a walk\",\n    completed: false\n};\n// -> 同步打印 'Completed 0 of 1 items'\n\ntodoStore.todos[0].completed = true;\n// -> 同步打印 'Completed 1 of 1 items'\n","export default abstract class Model<State> {\n    abstract namespace: string;\n    state: State;\n    constructor({ initialState }: { initialState: State }) {\n        if (this.state === undefined)\n            this.state = initialState;\n    }\n}","import Model from \"./models/Model\";\n\nexport type FuncName<T>  = {\n    [k in keyof T]: T[k] extends Function ? k : never;\n}[keyof T];\n\nexport type Dispatch = React.Dispatch<{payload: any; type: string}>;\nexport type Reducer<S, P = undefined, T = string> = (payload: P, type: T) => void | S; // TODO 是否可返回部分State？\n// type Reducer<S, P, T = string> = (state: S, payload: P, type: T) => S;\nexport type Effect<Actions, P, PromiseResult> = (actions: Actions, payload: P) => PromiseLike<PromiseResult>;\nexport type InvalidMethod = never;\nexport type InferFunc<S, Func> = Func extends Effect<S, infer P, infer PR> ? (payload: P) => PromiseLike<PR> :\n                            Func extends Reducer<S, infer P, infer T> ? (payload: P) => void : InvalidMethod;\n\nexport function infer<ModelClass extends Model<any>, ModelState, DispatchActions>() {\n    // type ModelMethods = Omit<ModelClass, 'state' | 'initialState' | 'namespace'>;\n    // type DispatchActions = {\n    //     [k in FuncName<ModelClass>]: InferFunc<ModelState, ModelClass[k]>\n    // }\n    return {\n        inferReducer<P = undefined>(handler: Reducer<ModelState, P>) {\n            return handler;\n        },\n        inferEffect<PR, P = undefined>(handler: Effect<DispatchActions, P, PR>) {\n            return handler;\n        },\n    }\n}","import Model from \"./Model\";\nimport { infer, FuncName, InferFunc } from \"../Tools\";\n\nconst inferObj = infer<Student, StudentState, DispatchActions>();\n\ntype DispatchActions = {\n    [k in FuncName<Student>]: InferFunc<StudentState, Student[k]>\n}\n\nlet delaySet = inferObj.inferEffect((actions, payload) => {\n    console.log(actions);\n    return Promise.resolve(1);\n});\n\nfunction enumerable(value: boolean) {\n    return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n        // debugger;\n        descriptor.enumerable = value;\n    };\n}\n\ntype StudentState = {\n    name: string;\n    id: string;\n}\nexport default class Student extends Model<StudentState> {\n    initialState = {\n        name: 'xx',\n        id: '1',\n    }\n    namespace: 'student'\n    constructor(config) {\n        super(config);\n        console.log(this.state);\n    }\n\n    @enumerable(false)\n    setName(payload: string) {\n        this.state.name = payload;\n    }\n    delay(actions: DispatchActions) {\n\n    }\n    delay3() {\n        return Promise.resolve(123);\n    }\n}","import App from \"./demo/App\";\nimport ReactDOM from \"react-dom\";\nimport React from \"react\";\nimport './mobx/Demo1';\nimport Student from \"./immer/models/Student\";\n\nlet wrapper = document.createElement('div');\n\ndocument.body.append(wrapper);\nReactDOM.render(<>\n    <App></App>\n    <h2>mobx demo</h2>\n    <hr/>\n</>, wrapper);\n\nlet stu = new Student({});"],"sourceRoot":""}